<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cache Simulation System</title>
    <style>
        body {
            display: flex;
            flex-direction: row;
        }

        .container {
            flex: 1;
            padding: 20px;
        }

        table {
            border-collapse: collapse;
            width: 50%;
            margin-bottom: 20px;
        }

        table, th, td {
            border: 1px solid black;
        }

        th, td {
            padding: 8px;
            text-align: center;
        }

        select, input, button {
            margin: 10px;
            padding: 8px;
        }

        textarea {
            width: 100%;
            height: 200px;
            margin-bottom: 20px;
        }

        .tg  {border-collapse:collapse;border-spacing:0;}
        .tg td{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:12px;
        overflow:hidden;padding:6px 4px;word-break:normal;}
        .tg th{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:12px;
        font-weight:normal;overflow:hidden;padding:6px 4px;word-break:normal;}
        .tg .tg-0lax{text-align:left;vertical-align:top}
    </style>
</head>
<body>
    <div class="container">
        <h2>Cache Simulation System</h2>

        <label for="testCases">Select Test Case:</label>
        <select id="testCases">
            <option value="sequential">Sequential Sequence</option>
            <option value="random">Random Sequence</option>
            <option value="midRepeat">Mid-Repeat Blocks</option>
        </select>

        <label for="memoryBlocks">Number of Memory Blocks:</label>
        <input type="number" id="memoryBlocks" min="1" placeholder="Enter the number of memory blocks">

        <button onclick="startSimulation()">Start Simulation</button>
        <button onclick="stepByStep()">Step by Step</button>
        <button onclick="skipToEnd()">Skip to End</button>

        <textarea id="textLog" readonly></textarea>
    </div>

    <div class="container">
        <table id="cacheTable">
            <thead>
                <tr>
                  <th class="tg-l2oz">Block</th>
                  <th class="tg-l2oz">Data</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td class="tg-lqy6">0</td>
                  <td class="tg-lqy6"></td>
                </tr>
                <tr>
                  <td class="tg-lqy6">1</td>
                  <td class="tg-lqy6"></td>
                </tr>
                <tr>
                  <td class="tg-lqy6">2</td>
                  <td class="tg-lqy6"></td>
                </tr>
                <tr>
                  <td class="tg-lqy6">3</td>
                  <td class="tg-lqy6"></td>
                </tr>
                <tr>
                  <td class="tg-lqy6">4</td>
                  <td class="tg-lqy6"></td>
                </tr>
                <tr>
                  <td class="tg-lqy6">5</td>
                  <td class="tg-lqy6"></td>
                </tr>
                <tr>
                  <td class="tg-lqy6">6</td>
                  <td class="tg-lqy6"></td>
                </tr>
                <tr>
                  <td class="tg-lqy6">7</td>
                  <td class="tg-lqy6"></td>
                </tr>
                <tr>
                  <td class="tg-lqy6">8</td>
                  <td class="tg-lqy6"></td>
                </tr>
                <tr>
                  <td class="tg-lqy6">9</td>
                  <td class="tg-lqy6"></td>
                </tr>
                <tr>
                  <td class="tg-lqy6">10</td>
                  <td class="tg-lqy6"></td>
                </tr>
                <tr>
                  <td class="tg-lqy6">11</td>
                  <td class="tg-lqy6"></td>
                </tr>
                <tr>
                  <td class="tg-lqy6">12</td>
                  <td class="tg-lqy6"></td>
                </tr>
                <tr>
                  <td class="tg-lqy6">13</td>
                  <td class="tg-lqy6"></td>
                </tr>
                <tr>
                  <td class="tg-lqy6">14</td>
                  <td class="tg-lqy6"></td>
                </tr>
                <tr>
                  <td class="tg-lqy6">15</td>
                  <td class="tg-lqy6"></td>
                </tr>
                <tr>
                  <td class="tg-lqy6">16</td>
                  <td class="tg-lqy6"></td>
                </tr>
                <tr>
                  <td class="tg-lqy6">17</td>
                  <td class="tg-lqy6"></td>
                </tr>
                <tr>
                  <td class="tg-lqy6">18</td>
                  <td class="tg-lqy6"></td>
                </tr>
                <tr>
                  <td class="tg-lqy6">19</td>
                  <td class="tg-lqy6"></td>
                </tr>
                <tr>
                  <td class="tg-lqy6">20</td>
                  <td class="tg-lqy6"></td>
                </tr>
                <tr>
                  <td class="tg-lqy6">21</td>
                  <td class="tg-lqy6"></td>
                </tr>
                <tr>
                  <td class="tg-lqy6">22</td>
                  <td class="tg-lqy6"></td>
                </tr>
                <tr>
                  <td class="tg-lqy6">23</td>
                  <td class="tg-lqy6"></td>
                </tr>
                <tr>
                  <td class="tg-lqy6">24</td>
                  <td class="tg-lqy6"></td>
                </tr>
                <tr>
                  <td class="tg-lqy6">25</td>
                  <td class="tg-lqy6"></td>
                </tr>
                <tr>
                  <td class="tg-lqy6">26</td>
                  <td class="tg-lqy6"></td>
                </tr>
                <tr>
                  <td class="tg-lqy6">27</td>
                  <td class="tg-lqy6"></td>
                </tr>
                <tr>
                  <td class="tg-lqy6">28</td>
                  <td class="tg-lqy6"></td>
                </tr>
                <tr>
                  <td class="tg-lqy6">29</td>
                  <td class="tg-lqy6"></td>
                </tr>
                <tr>
                  <td class="tg-0lax">30</td>
                  <td class="tg-0lax"></td>
                </tr>
                <tr>
                  <td class="tg-lqy6">31</td>
                  <td class="tg-lqy6"></td>
                </tr>
              </tbody>
        </table>
    </div>

    <script>
        let cacheSize = 32; // Assuming 32 cache blocks
        let memoryBlocks = []; // Array to store memory blocks
        let cacheMemory = new Array(cacheSize).fill(null); // Initialize cache memory array
        let currentStep = 0; // Variable to keep track of the current simulation step
        let totalAccesses = 0;
        let cacheHits = 0;
        let cacheMisses = 0;

        function startSimulation() {
            // Clear the text log
            document.getElementById('textLog').value = '';
            // Reset cache and memory
            cacheMemory.fill(null);
            memoryBlocks = [];

            // Clear the cache table
            clearCacheTable();
            
            totalAccesses = 0;
            cacheHits = 0;
            cacheMisses = 0;
            // Initialize memory blocks
            let numberOfBlocks = parseInt(document.getElementById('memoryBlocks').value);
            for (let i = 0; i < numberOfBlocks; i++) {
                memoryBlocks.push(i);
            }

            // Perform the sequential sequence test case
            currentStep = 0;
            //fullAssociativeTest();
        }

        function sequentialTest() {
            // Calculate the current iteration values
            let i = Math.floor(currentStep / memoryBlocks.length);
            let blockIndex = currentStep % memoryBlocks.length;

            // Check if the current step is within the total number of accesses
            if (currentStep < memoryBlocks.length * 4) {
                // Increment the total accesses only once per step
                totalAccesses++;

                // Process the block based on the current iteration
                let blockNumber = memoryBlocks[blockIndex];

                // Check if the block is in the cache
                let cacheIndex = cacheMemory.indexOf(blockNumber);
                if (cacheIndex !== -1) {
                    // Cache hit
                    cacheHits++;
                } else {
                    // Cache miss
                    cacheMisses++;

                    if (cacheMemory.includes(null)) {
                        // Cache is not full, use first come first serve (FIFO) or direct mapping
                        cacheIndex = cacheMemory.findIndex((block) => block === null);
                    } else {
                        // Cache is full, use random replacement algorithm
                        cacheIndex = Math.floor(Math.random() * cacheSize);
                    }

                    // Update cache
                    cacheMemory[cacheIndex] = blockNumber;
                }

                // Update the text log only if it's a new step
                updateTextLog(`Step: ${totalAccesses}, Block: ${blockNumber}, Cache Hit: ${cacheHits}, Cache Miss: ${cacheMisses}`);
            }

            // Increment the current step after completing the simulation for the current step
            currentStep++;

            // Display final statistics if the simulation is complete
            if (currentStep >= memoryBlocks.length * 4) {
                displayFinalStatistics();
            }

            // Update the cache table after the loop completes
            updateCacheTable();
        }

        function generateRandomSequence(length) {
            let randomSequence = [];
            
            for (let i = 0; i < length; i++) {
                randomSequence.push(Math.floor(Math.random() * length));
            }

            return randomSequence;
        }



        function randomTest() {
            // Check if the current step is within the total number of accesses
            if (currentStep < 4 * memoryBlocks.length) {
                // Clear the cache table before starting the test
                clearCacheTable();

                // Generate a random sequence of 4n memory block accesses
                let randomSequence = generateRandomSequence(4 * memoryBlocks.length);

                // Increment the total accesses only once per step
                totalAccesses++;

                let blockNumber = randomSequence[currentStep];

                // Check if the block is in the cache
                let cacheIndex = cacheMemory.indexOf(blockNumber);
                if (cacheIndex !== -1) {
                    // Cache hit
                    cacheHits++;
                } else {
                    // Cache miss
                    cacheMisses++;

                    if (cacheMemory.includes(null)) {
                        // Cache is not full, use first come first serve (FIFO) or direct mapping
                        cacheIndex = cacheMemory.findIndex((block) => block === null);
                    } else {
                        // Cache is full, use random replacement algorithm
                        cacheIndex = Math.floor(Math.random() * cacheSize);
                    }

                    // Update cache
                    cacheMemory[cacheIndex] = blockNumber;
                }

                // Update the text log only if it's a new step
                updateTextLog(`Step: ${totalAccesses}, Block: ${blockNumber}, Cache Hit: ${cacheHits}, Cache Miss: ${cacheMisses}`);

                // Update the cache table after each step
                updateCacheTable();

                // Increment the current step after completing the simulation for the current step
                currentStep++;

                // Display final statistics if the simulation is complete
                if (currentStep >= 4 * memoryBlocks.length) {
                    displayFinalStatistics();
                }
            }
        }

        function generateMidRepeatSequence(n) {
            let sequence = [];


            // Repeat the sequence in the middle twice up to n-1 blocks
            for (let m = 0; m <4; m++){
                sequence.push(0);
                for (let i = 0; i < 2; i++) {
                    for (let j = 1; j < n-1; j++) {
                        sequence.push(j);
                    }
                }

                // Continue up to 2n
                for (let k = n-1; k < 2 * n; k++) {
                    sequence.push(k);
                }
            }
            console.log(sequence.length);
            return sequence;
        }


        function midRepeatTest() {
            // Check if the current step is within the total number of accesses
            
            // Generate the mid-repeat sequence
            let midRepeatSequence = generateMidRepeatSequence(memoryBlocks.length);

            if (currentStep < midRepeatSequence.length) {
                // Clear the cache table before starting the test
                clearCacheTable();

                // Increment the total accesses only once per step
                totalAccesses++;

                let blockNumber = midRepeatSequence[currentStep];

                // Check if the block is in the cache
                let cacheIndex = cacheMemory.indexOf(blockNumber);
                if (cacheIndex !== -1) {
                    // Cache hit
                    cacheHits++;
                } else {
                    // Cache miss
                    cacheMisses++;

                    if (cacheMemory.includes(null)) {
                        // Cache is not full, use first come first serve (FIFO) or direct mapping
                        cacheIndex = cacheMemory.findIndex((block) => block === null);
                    } else {
                        // Cache is full, use random replacement algorithm
                        cacheIndex = Math.floor(Math.random() * cacheSize);
                    }

                    // Update cache
                    cacheMemory[cacheIndex] = blockNumber;
                }

                // Update the text log only if it's a new step
                updateTextLog(`Step: ${totalAccesses}, Block: ${blockNumber}, Cache Hit: ${cacheHits}, Cache Miss: ${cacheMisses}`);

                // Update the cache table after each step
                updateCacheTable();

                // Increment the current step after completing the simulation for the current step
                currentStep++;

                // Display final statistics if the simulation is complete
                if (currentStep >= midRepeatSequence.length) {
                    displayFinalStatistics();
                }
            }
        }




        function updateCacheTable() {
            // Clear the table body before inserting new rows
            let tableBody = document.getElementById('cacheTable').getElementsByTagName('tbody')[0];
            tableBody.innerHTML = '';

            for (let i = 0; i < cacheSize; i++) {
                let row = tableBody.insertRow(-1);
                let cell1 = row.insertCell(0);
                let cell2 = row.insertCell(1);

                cell1.innerHTML = i;
                cell2.innerHTML = cacheMemory[i] !== null ? cacheMemory[i] : '';
            }
        }

        function clearCacheTable() {
            // Clear the values under the "Data" column only
            let tableBody = document.getElementById('cacheTable').getElementsByTagName('tbody')[0];
            let rows = tableBody.getElementsByTagName('tr');

            for (let i = 0; i < rows.length; i++) {
                let cells = rows[i].getElementsByTagName('td');
                if (cells.length > 1) {
                    // Set the content of the second cell (Data) to an empty string
                    cells[1].innerHTML = '';
                }
            }
        }



        function stepByStep() {
            // Perform the selected test case
            let selectedTestCase = document.getElementById('testCases').value;
            if (selectedTestCase === 'sequential') {
                sequentialTest();
            } else if (selectedTestCase === 'random') {
                randomTest();
            } else if (selectedTestCase === 'midRepeat') {
                midRepeatTest();
            }
        }


        function skipToEnd() {
            // Code to skip to the end of the simulation
            let selectedTestCase = document.getElementById('testCases').value;
            if (selectedTestCase === 'sequential') {
                while (currentStep < memoryBlocks.length * 4) {
                sequentialTest();
                }
            } else if (selectedTestCase === 'random') {
                while (currentStep < memoryBlocks.length * 4) {
                randomTest();
                }
            } else if (selectedTestCase === 'midRepeat') {
                    // Generate the mid-repeat sequence
                let midRepeatSequence = generateMidRepeatSequence(memoryBlocks.length);
                while (currentStep < midRepeatSequence.length) {
                midRepeatTest();
                }
            }
            
        }

        function displayFinalStatistics() {
            let hitRate = cacheHits / totalAccesses;
            let missRate = cacheMisses / totalAccesses;

            updateTextLog(`--- Test Case Complete ---`);
            updateTextLog(`Total Accesses: ${totalAccesses}`);
            updateTextLog(`Cache Hits: ${cacheHits}`);
            updateTextLog(`Cache Misses: ${cacheMisses}`);
            updateTextLog(`Cache Hit Rate: ${(hitRate * 100).toFixed(2)}%`);
            updateTextLog(`Cache Miss Rate: ${(missRate * 100).toFixed(2)}%`);
        }

        function updateTextLog(message) {
            var textLog = document.getElementById('textLog');
            textLog.value += message + '\n';
        }

    </script>
    
</body>
</html>